// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: roles.sql

package sqldb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRoleAssignments = `-- name: CountRoleAssignments :one
SELECT COUNT(*) AS total
FROM role_assignments
WHERE role_id = $1
`

func (q *Queries) CountRoleAssignments(ctx context.Context, roleID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countRoleAssignments, roleID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countRoles = `-- name: CountRoles :one
SELECT COUNT(*) AS total
FROM roles r
WHERE
    ($1::text IS NULL OR r.scope = $1::text)
    AND (
        $2::uuid IS NULL
        OR r.tenant_id = $2::uuid
    )
    AND (
        $3::text IS NULL
        OR r.code ILIKE '%' || $3::text || '%'
        OR r.name ILIKE '%' || $3::text || '%'
    )
`

type CountRolesParams struct {
	ScopeFilter  *string     `json:"scope_filter"`
	TenantFilter pgtype.UUID `json:"tenant_filter"`
	Search       *string     `json:"search"`
}

func (q *Queries) CountRoles(ctx context.Context, arg CountRolesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRoles, arg.ScopeFilter, arg.TenantFilter, arg.Search)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (
    id,
    tenant_id,
    scope,
    code,
    name,
    description,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    COALESCE($7::jsonb, '{}'::jsonb)
) RETURNING
    id,
    tenant_id,
    scope,
    code,
    name,
    description,
    metadata,
    created_at,
    updated_at,
    version
`

type CreateRoleParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Scope       string      `json:"scope"`
	Code        string      `json:"code"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	Metadata    []byte      `json:"metadata"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, createRole,
		arg.ID,
		arg.TenantID,
		arg.Scope,
		arg.Code,
		arg.Name,
		arg.Description,
		arg.Metadata,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Scope,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles
WHERE id = $1
`

func (q *Queries) DeleteRole(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRole, id)
	return err
}

const deleteRoleAssignment = `-- name: DeleteRoleAssignment :exec
DELETE FROM role_assignments
WHERE role_id = $1
  AND identity_id = $2
`

type DeleteRoleAssignmentParams struct {
	RoleID     pgtype.UUID `json:"role_id"`
	IdentityID pgtype.UUID `json:"identity_id"`
}

func (q *Queries) DeleteRoleAssignment(ctx context.Context, arg DeleteRoleAssignmentParams) error {
	_, err := q.db.Exec(ctx, deleteRoleAssignment, arg.RoleID, arg.IdentityID)
	return err
}

const deleteRolePermissions = `-- name: DeleteRolePermissions :exec
DELETE FROM role_permissions
WHERE role_id = $1
`

func (q *Queries) DeleteRolePermissions(ctx context.Context, roleID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRolePermissions, roleID)
	return err
}

const getRole = `-- name: GetRole :one
SELECT
    r.id,
    r.tenant_id,
    r.scope,
    r.code,
    r.name,
    r.description,
    r.metadata,
    r.created_at,
    r.updated_at,
    r.version,
    COALESCE(ra.assigned_count, 0)::bigint AS assigned_count
FROM roles r
LEFT JOIN (
    SELECT role_id, COUNT(*) AS assigned_count
    FROM role_assignments
    GROUP BY role_id
) ra ON ra.role_id = r.id
WHERE r.id = $1
`

type GetRoleRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	Scope         string             `json:"scope"`
	Code          string             `json:"code"`
	Name          string             `json:"name"`
	Description   *string            `json:"description"`
	Metadata      []byte             `json:"metadata"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Version       int32              `json:"version"`
	AssignedCount int64              `json:"assigned_count"`
}

func (q *Queries) GetRole(ctx context.Context, id pgtype.UUID) (GetRoleRow, error) {
	row := q.db.QueryRow(ctx, getRole, id)
	var i GetRoleRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Scope,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
		&i.AssignedCount,
	)
	return i, err
}

const insertRolePermission = `-- name: InsertRolePermission :exec
INSERT INTO role_permissions (role_id, permission_code)
VALUES ($1, $2)
ON CONFLICT (role_id, permission_code) DO NOTHING
`

type InsertRolePermissionParams struct {
	RoleID         pgtype.UUID `json:"role_id"`
	PermissionCode string      `json:"permission_code"`
}

func (q *Queries) InsertRolePermission(ctx context.Context, arg InsertRolePermissionParams) error {
	_, err := q.db.Exec(ctx, insertRolePermission, arg.RoleID, arg.PermissionCode)
	return err
}

const listRoleAssignments = `-- name: ListRoleAssignments :many
SELECT
    ra.role_id,
    ra.identity_id,
    ra.tenant_id,
    ra.created_at
FROM role_assignments ra
WHERE ra.role_id = $1
ORDER BY ra.created_at DESC
LIMIT COALESCE($3::int, 50)
OFFSET COALESCE($2::int, 0)
`

type ListRoleAssignmentsParams struct {
	RoleID      pgtype.UUID `json:"role_id"`
	OffsetValue *int32      `json:"offset_value"`
	LimitValue  *int32      `json:"limit_value"`
}

func (q *Queries) ListRoleAssignments(ctx context.Context, arg ListRoleAssignmentsParams) ([]RoleAssignment, error) {
	rows, err := q.db.Query(ctx, listRoleAssignments, arg.RoleID, arg.OffsetValue, arg.LimitValue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoleAssignment
	for rows.Next() {
		var i RoleAssignment
		if err := rows.Scan(
			&i.RoleID,
			&i.IdentityID,
			&i.TenantID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRolePermissions = `-- name: ListRolePermissions :many
SELECT permission_code
FROM role_permissions
WHERE role_id = $1
ORDER BY permission_code ASC
`

func (q *Queries) ListRolePermissions(ctx context.Context, roleID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, listRolePermissions, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var permission_code string
		if err := rows.Scan(&permission_code); err != nil {
			return nil, err
		}
		items = append(items, permission_code)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT
    r.id,
    r.tenant_id,
    r.scope,
    r.code,
    r.name,
    r.description,
    r.metadata,
    r.created_at,
    r.updated_at,
    r.version,
    COALESCE(ra.assigned_count, 0)::bigint AS assigned_count
FROM roles r
LEFT JOIN (
    SELECT role_id, COUNT(*) AS assigned_count
    FROM role_assignments
    GROUP BY role_id
) ra ON ra.role_id = r.id
WHERE
    ($1::text IS NULL OR r.scope = $1::text)
    AND (
        $2::uuid IS NULL
        OR r.tenant_id = $2::uuid
    )
    AND (
        $3::text IS NULL
        OR r.code ILIKE '%' || $3::text || '%'
        OR r.name ILIKE '%' || $3::text || '%'
    )
ORDER BY r.created_at DESC
LIMIT COALESCE($5::int, 50)
OFFSET COALESCE($4::int, 0)
`

type ListRolesParams struct {
	ScopeFilter  *string     `json:"scope_filter"`
	TenantFilter pgtype.UUID `json:"tenant_filter"`
	Search       *string     `json:"search"`
	OffsetValue  *int32      `json:"offset_value"`
	LimitValue   *int32      `json:"limit_value"`
}

type ListRolesRow struct {
	ID            pgtype.UUID        `json:"id"`
	TenantID      pgtype.UUID        `json:"tenant_id"`
	Scope         string             `json:"scope"`
	Code          string             `json:"code"`
	Name          string             `json:"name"`
	Description   *string            `json:"description"`
	Metadata      []byte             `json:"metadata"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Version       int32              `json:"version"`
	AssignedCount int64              `json:"assigned_count"`
}

func (q *Queries) ListRoles(ctx context.Context, arg ListRolesParams) ([]ListRolesRow, error) {
	rows, err := q.db.Query(ctx, listRoles,
		arg.ScopeFilter,
		arg.TenantFilter,
		arg.Search,
		arg.OffsetValue,
		arg.LimitValue,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRolesRow
	for rows.Next() {
		var i ListRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Scope,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Version,
			&i.AssignedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles
SET
    code = $1,
    name = $2,
    description = $3,
    metadata = COALESCE($4::jsonb, metadata),
    updated_at = NOW(),
    version = version + 1
WHERE id = $5
RETURNING
    id,
    tenant_id,
    scope,
    code,
    name,
    description,
    metadata,
    created_at,
    updated_at,
    version
`

type UpdateRoleParams struct {
	Code        string      `json:"code"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	Metadata    []byte      `json:"metadata"`
	ID          pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, updateRole,
		arg.Code,
		arg.Name,
		arg.Description,
		arg.Metadata,
		arg.ID,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Scope,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Version,
	)
	return i, err
}

const upsertRoleAssignment = `-- name: UpsertRoleAssignment :exec
INSERT INTO role_assignments (role_id, identity_id, tenant_id)
VALUES ($1, $2, $3)
ON CONFLICT (role_id, identity_id)
DO UPDATE SET tenant_id = EXCLUDED.tenant_id
`

type UpsertRoleAssignmentParams struct {
	RoleID     pgtype.UUID `json:"role_id"`
	IdentityID pgtype.UUID `json:"identity_id"`
	TenantID   pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) UpsertRoleAssignment(ctx context.Context, arg UpsertRoleAssignmentParams) error {
	_, err := q.db.Exec(ctx, upsertRoleAssignment, arg.RoleID, arg.IdentityID, arg.TenantID)
	return err
}
