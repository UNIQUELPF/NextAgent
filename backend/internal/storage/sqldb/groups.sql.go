// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: groups.sql

package sqldb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countChildGroups = `-- name: CountChildGroups :one
SELECT COUNT(*)
FROM tenant_groups
WHERE parent_id = $1
`

func (q *Queries) CountChildGroups(ctx context.Context, parentID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChildGroups, parentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGroupMembersWithSearch = `-- name: CountGroupMembersWithSearch :one
SELECT COUNT(*)
FROM group_members
WHERE group_id = $1
  AND (
      $2::text IS NULL
      OR display_name ILIKE '%' || $2::text || '%'
      OR phone ILIKE '%' || $2::text || '%'
  )
`

type CountGroupMembersWithSearchParams struct {
	GroupID pgtype.UUID `json:"group_id"`
	Search  *string     `json:"search"`
}

func (q *Queries) CountGroupMembersWithSearch(ctx context.Context, arg CountGroupMembersWithSearchParams) (int64, error) {
	row := q.db.QueryRow(ctx, countGroupMembersWithSearch, arg.GroupID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMembersInGroup = `-- name: CountMembersInGroup :one
SELECT COUNT(*)
FROM group_members
WHERE group_id = $1
`

func (q *Queries) CountMembersInGroup(ctx context.Context, groupID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMembersInGroup, groupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGroupMember = `-- name: CreateGroupMember :one
INSERT INTO group_members (
    group_id,
    identity_id,
    tenant_id,
    display_name,
    phone,
    title,
    is_primary
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    COALESCE($7::boolean, FALSE)
)
ON CONFLICT (group_id, identity_id) DO UPDATE
SET
    display_name = EXCLUDED.display_name,
    phone = EXCLUDED.phone,
    title = EXCLUDED.title,
    is_primary = EXCLUDED.is_primary,
    updated_at = NOW()
RETURNING
    group_id,
    identity_id,
    tenant_id,
    display_name,
    phone,
    title,
    is_primary,
    created_at,
    updated_at
`

type CreateGroupMemberParams struct {
	GroupID     pgtype.UUID `json:"group_id"`
	IdentityID  pgtype.UUID `json:"identity_id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	DisplayName string      `json:"display_name"`
	Phone       string      `json:"phone"`
	Title       *string     `json:"title"`
	IsPrimary   bool        `json:"is_primary"`
}

func (q *Queries) CreateGroupMember(ctx context.Context, arg CreateGroupMemberParams) (GroupMember, error) {
	row := q.db.QueryRow(ctx, createGroupMember,
		arg.GroupID,
		arg.IdentityID,
		arg.TenantID,
		arg.DisplayName,
		arg.Phone,
		arg.Title,
		arg.IsPrimary,
	)
	var i GroupMember
	err := row.Scan(
		&i.GroupID,
		&i.IdentityID,
		&i.TenantID,
		&i.DisplayName,
		&i.Phone,
		&i.Title,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTenantGroup = `-- name: CreateTenantGroup :one
INSERT INTO tenant_groups (
    id,
    tenant_id,
    code,
    name,
    description,
    parent_id,
    sort_order,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    COALESCE($7::int, 0),
    COALESCE($8::jsonb, '{}'::jsonb)
)
RETURNING
    id,
    tenant_id,
    code,
    name,
    description,
    parent_id,
    sort_order,
    metadata,
    created_at,
    updated_at
`

type CreateTenantGroupParams struct {
	ID          pgtype.UUID `json:"id"`
	TenantID    pgtype.UUID `json:"tenant_id"`
	Code        string      `json:"code"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	ParentID    pgtype.UUID `json:"parent_id"`
	SortOrder   int32       `json:"sort_order"`
	Metadata    []byte      `json:"metadata"`
}

func (q *Queries) CreateTenantGroup(ctx context.Context, arg CreateTenantGroupParams) (TenantGroup, error) {
	row := q.db.QueryRow(ctx, createTenantGroup,
		arg.ID,
		arg.TenantID,
		arg.Code,
		arg.Name,
		arg.Description,
		arg.ParentID,
		arg.SortOrder,
		arg.Metadata,
	)
	var i TenantGroup
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.ParentID,
		&i.SortOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGroupMember = `-- name: DeleteGroupMember :exec
DELETE FROM group_members
WHERE group_id = $1
  AND identity_id = $2
`

type DeleteGroupMemberParams struct {
	GroupID    pgtype.UUID `json:"group_id"`
	IdentityID pgtype.UUID `json:"identity_id"`
}

func (q *Queries) DeleteGroupMember(ctx context.Context, arg DeleteGroupMemberParams) error {
	_, err := q.db.Exec(ctx, deleteGroupMember, arg.GroupID, arg.IdentityID)
	return err
}

const deleteTenantGroup = `-- name: DeleteTenantGroup :exec
DELETE FROM tenant_groups
WHERE id = $1
`

func (q *Queries) DeleteTenantGroup(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTenantGroup, id)
	return err
}

const getTenantGroup = `-- name: GetTenantGroup :one
SELECT
    id,
    tenant_id,
    code,
    name,
    description,
    parent_id,
    sort_order,
    metadata,
    created_at,
    updated_at
FROM tenant_groups
WHERE id = $1
`

func (q *Queries) GetTenantGroup(ctx context.Context, id pgtype.UUID) (TenantGroup, error) {
	row := q.db.QueryRow(ctx, getTenantGroup, id)
	var i TenantGroup
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.ParentID,
		&i.SortOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllGroups = `-- name: ListAllGroups :many
SELECT
    id,
    tenant_id,
    code,
    name,
    description,
    parent_id,
    sort_order,
    metadata,
    created_at,
    updated_at
FROM tenant_groups
ORDER BY tenant_id, sort_order ASC, name ASC
`

func (q *Queries) ListAllGroups(ctx context.Context) ([]TenantGroup, error) {
	rows, err := q.db.Query(ctx, listAllGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TenantGroup
	for rows.Next() {
		var i TenantGroup
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.ParentID,
			&i.SortOrder,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupMembers = `-- name: ListGroupMembers :many
SELECT
    group_id,
    identity_id,
    tenant_id,
    display_name,
    phone,
    title,
    is_primary,
    created_at,
    updated_at
FROM group_members
WHERE group_id = $1
  AND (
      $2::text IS NULL
      OR display_name ILIKE '%' || $2::text || '%'
      OR phone ILIKE '%' || $2::text || '%'
  )
ORDER BY created_at DESC
LIMIT COALESCE($4::int, 50)
OFFSET COALESCE($3::int, 0)
`

type ListGroupMembersParams struct {
	GroupID     pgtype.UUID `json:"group_id"`
	Search      *string     `json:"search"`
	OffsetValue *int32      `json:"offset_value"`
	LimitValue  *int32      `json:"limit_value"`
}

func (q *Queries) ListGroupMembers(ctx context.Context, arg ListGroupMembersParams) ([]GroupMember, error) {
	rows, err := q.db.Query(ctx, listGroupMembers,
		arg.GroupID,
		arg.Search,
		arg.OffsetValue,
		arg.LimitValue,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GroupMember
	for rows.Next() {
		var i GroupMember
		if err := rows.Scan(
			&i.GroupID,
			&i.IdentityID,
			&i.TenantID,
			&i.DisplayName,
			&i.Phone,
			&i.Title,
			&i.IsPrimary,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupsForIdentity = `-- name: ListGroupsForIdentity :many
SELECT
    group_id,
    identity_id,
    tenant_id,
    display_name,
    phone,
    title,
    is_primary,
    created_at,
    updated_at
FROM group_members
WHERE tenant_id = $1
  AND identity_id = $2
`

type ListGroupsForIdentityParams struct {
	TenantID   pgtype.UUID `json:"tenant_id"`
	IdentityID pgtype.UUID `json:"identity_id"`
}

func (q *Queries) ListGroupsForIdentity(ctx context.Context, arg ListGroupsForIdentityParams) ([]GroupMember, error) {
	rows, err := q.db.Query(ctx, listGroupsForIdentity, arg.TenantID, arg.IdentityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GroupMember
	for rows.Next() {
		var i GroupMember
		if err := rows.Scan(
			&i.GroupID,
			&i.IdentityID,
			&i.TenantID,
			&i.DisplayName,
			&i.Phone,
			&i.Title,
			&i.IsPrimary,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemberCounts = `-- name: ListMemberCounts :many
SELECT
    group_id,
    COUNT(*) AS member_count
FROM group_members
GROUP BY group_id
`

type ListMemberCountsRow struct {
	GroupID     pgtype.UUID `json:"group_id"`
	MemberCount int64       `json:"member_count"`
}

func (q *Queries) ListMemberCounts(ctx context.Context) ([]ListMemberCountsRow, error) {
	rows, err := q.db.Query(ctx, listMemberCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMemberCountsRow
	for rows.Next() {
		var i ListMemberCountsRow
		if err := rows.Scan(&i.GroupID, &i.MemberCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMemberCountsForTenant = `-- name: ListMemberCountsForTenant :many
SELECT
    group_id,
    COUNT(*) AS member_count
FROM group_members
WHERE tenant_id = $1
GROUP BY group_id
`

type ListMemberCountsForTenantRow struct {
	GroupID     pgtype.UUID `json:"group_id"`
	MemberCount int64       `json:"member_count"`
}

func (q *Queries) ListMemberCountsForTenant(ctx context.Context, tenantID pgtype.UUID) ([]ListMemberCountsForTenantRow, error) {
	rows, err := q.db.Query(ctx, listMemberCountsForTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMemberCountsForTenantRow
	for rows.Next() {
		var i ListMemberCountsForTenantRow
		if err := rows.Scan(&i.GroupID, &i.MemberCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenantGroups = `-- name: ListTenantGroups :many
SELECT
    id,
    tenant_id,
    code,
    name,
    description,
    parent_id,
    sort_order,
    metadata,
    created_at,
    updated_at
FROM tenant_groups
WHERE tenant_id = $1
ORDER BY sort_order ASC, name ASC
`

func (q *Queries) ListTenantGroups(ctx context.Context, tenantID pgtype.UUID) ([]TenantGroup, error) {
	rows, err := q.db.Query(ctx, listTenantGroups, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TenantGroup
	for rows.Next() {
		var i TenantGroup
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Code,
			&i.Name,
			&i.Description,
			&i.ParentID,
			&i.SortOrder,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveGroupMember = `-- name: MoveGroupMember :one
UPDATE group_members
SET
    group_id = $1,
    tenant_id = $2,
    updated_at = NOW()
WHERE group_id = $3
  AND identity_id = $4
RETURNING
    group_id,
    identity_id,
    tenant_id,
    display_name,
    phone,
    title,
    is_primary,
    created_at,
    updated_at
`

type MoveGroupMemberParams struct {
	NewGroupID pgtype.UUID `json:"new_group_id"`
	TenantID   pgtype.UUID `json:"tenant_id"`
	GroupID    pgtype.UUID `json:"group_id"`
	IdentityID pgtype.UUID `json:"identity_id"`
}

func (q *Queries) MoveGroupMember(ctx context.Context, arg MoveGroupMemberParams) (GroupMember, error) {
	row := q.db.QueryRow(ctx, moveGroupMember,
		arg.NewGroupID,
		arg.TenantID,
		arg.GroupID,
		arg.IdentityID,
	)
	var i GroupMember
	err := row.Scan(
		&i.GroupID,
		&i.IdentityID,
		&i.TenantID,
		&i.DisplayName,
		&i.Phone,
		&i.Title,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGroupMember = `-- name: UpdateGroupMember :one
UPDATE group_members
SET
    display_name = $1,
    phone = $2,
    title = $3,
    is_primary = COALESCE($4::boolean, is_primary),
    updated_at = NOW()
WHERE group_id = $5
  AND identity_id = $6
RETURNING
    group_id,
    identity_id,
    tenant_id,
    display_name,
    phone,
    title,
    is_primary,
    created_at,
    updated_at
`

type UpdateGroupMemberParams struct {
	DisplayName string      `json:"display_name"`
	Phone       string      `json:"phone"`
	Title       *string     `json:"title"`
	IsPrimary   bool        `json:"is_primary"`
	GroupID     pgtype.UUID `json:"group_id"`
	IdentityID  pgtype.UUID `json:"identity_id"`
}

func (q *Queries) UpdateGroupMember(ctx context.Context, arg UpdateGroupMemberParams) (GroupMember, error) {
	row := q.db.QueryRow(ctx, updateGroupMember,
		arg.DisplayName,
		arg.Phone,
		arg.Title,
		arg.IsPrimary,
		arg.GroupID,
		arg.IdentityID,
	)
	var i GroupMember
	err := row.Scan(
		&i.GroupID,
		&i.IdentityID,
		&i.TenantID,
		&i.DisplayName,
		&i.Phone,
		&i.Title,
		&i.IsPrimary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTenantGroup = `-- name: UpdateTenantGroup :one
UPDATE tenant_groups
SET
    code = $1,
    name = $2,
    description = $3,
    parent_id = $4,
    sort_order = COALESCE($5::int, sort_order),
    metadata = COALESCE($6::jsonb, metadata),
    updated_at = NOW()
WHERE id = $7
RETURNING
    id,
    tenant_id,
    code,
    name,
    description,
    parent_id,
    sort_order,
    metadata,
    created_at,
    updated_at
`

type UpdateTenantGroupParams struct {
	Code        string      `json:"code"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	ParentID    pgtype.UUID `json:"parent_id"`
	SortOrder   int32       `json:"sort_order"`
	Metadata    []byte      `json:"metadata"`
	ID          pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateTenantGroup(ctx context.Context, arg UpdateTenantGroupParams) (TenantGroup, error) {
	row := q.db.QueryRow(ctx, updateTenantGroup,
		arg.Code,
		arg.Name,
		arg.Description,
		arg.ParentID,
		arg.SortOrder,
		arg.Metadata,
		arg.ID,
	)
	var i TenantGroup
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Code,
		&i.Name,
		&i.Description,
		&i.ParentID,
		&i.SortOrder,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
